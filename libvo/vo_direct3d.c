/*
 * Copyright (c) 2008 Georgi Petrov (gogothebee) <gogothebee@gmail.com>
 *
 * This file is part of MPlayer.
 *
 * MPlayer is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * MPlayer is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with MPlayer; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

#include <windows.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <stdbool.h>
#include <assert.h>
#include <d3d9.h>
#include "config.h"
#include "options.h"
#include "subopt-helper.h"
#include "talloc.h"
#include "video_out.h"
#include "libmpcodecs/vfcap.h"
// for global_vo
#include "old_vo_wrapper.h"
#include "csputils.h"
#include "libmpcodecs/mp_image.h"
#include "libmpcodecs/img_format.h"
#include "fastmemcpy.h"
#include "mp_msg.h"
#include "aspect.h"
#include "w32_common.h"
#include "libavutil/common.h"
#include "sub/font_load.h"
#include "sub/sub.h"
#include "eosd_packer.h"

// shaders generated by fxc.exe from d3d_shader_yuv.hlsl
#include "d3d_shader_yuv.h"


// TODO: beg someone to add this (there is already IMGFMT_Y8)
// equals MAKEFOURCC('Y', '1', '6', ' ')
#define IMGFMT_Y16 0x20363159

#define IMGFMT_IS_Y(x) ((x) == IMGFMT_Y8 || (x) == IMGFMT_Y16)
#define IMGFMT_Y_DEPTH(x) ((x) == IMGFMT_Y8 ? 8 : 16)

#define DEVTYPE D3DDEVTYPE_HAL
//#define DEVTYPE D3DDEVTYPE_REF


#define D3DFVF_OSD_VERTEX (D3DFVF_XYZ | D3DFVF_TEX1)

typedef struct {
    float x, y, z;      /* Position of vertex in 3D space */
    float tu, tv;       /* Texture coordinates */
} vertex_osd;

#define D3DFVF_EOSD_VERTEX (D3DFVF_XYZ | D3DFVF_TEX1 | D3DFVF_DIFFUSE)

typedef struct {
    float x, y, z;
    D3DCOLOR color;
    float tu, tv;
} vertex_eosd;

#define D3DFVF_VIDEO_VERTEX (D3DFVF_XYZ | D3DFVF_TEX3)

typedef struct {
    float x, y, z;
    // pairs of texture coordinates for up to 3 planes
    float t[3][2];
} vertex_video;


struct d3dtex {
    // user-requested size
    int w, h;
    // allocated texture size
    int tex_w, tex_h;
    // D3DPOOL_SYSTEMMEM texture:
    // - can be locked in order to write (and even read) data
    // - can _not_ (probably) be used as texture for rendering
    // This is always non-NULL if d3dtex_allocate succeeds.
    IDirect3DTexture9 *system;
    // D3DPOOL_DEFAULT texture:
    // - can't be locked (Probably.)
    // - must be used for rendering
    // This will be NULL on systems with device_texture_sys != 0.
    IDirect3DTexture9 *device;
};

struct texplane {
    int bytes_per_pixel;
    int bits_per_pixel;
    // chroma shifts
    // e.g. get the plane's width in pixels with (priv->src_width >> shift_x)
    int shift_x, shift_y;
    D3DFORMAT d3d_format;
    struct d3dtex texture;
    // temporary locking during uploading the frame (e.g. for draw_slice)
    D3DLOCKED_RECT locked_rect;
    // value used to clear the image with memset (YUV chroma planes do not use
    // the value 0 for this)
    uint8_t clearval;
};

/* Global variables "priv" structure. I try to keep their count low.
 */
typedef struct d3d_priv {
    int opt_prefer_stretchrect;
    int opt_disable_textures;
    int opt_disable_stretchrect;
    int opt_disable_shaders;
    int opt_only_8bit;
    int opt_disable_eosd;
    int opt_disable_texture_align;

    struct vo *vo;

    int is_clear_needed;        /**< 1 = Clear the backbuffer before StretchRect
                                0 = (default) Don't clear it */
    D3DLOCKED_RECT locked_rect; /**< The locked offscreen surface */
    RECT fs_movie_rect;         /**< Rect (upscaled) of the movie when displayed
                                in fullscreen */
    RECT fs_panscan_rect;       /**< PanScan source surface cropping in
                                fullscreen */
    int src_width;              /**< Source (movie) width */
    int src_height;             /**< Source (movie) heigth */
    int border_x;               /**< horizontal border value for OSD */
    int border_y;               /**< vertical border value for OSD */
    int image_format;           /**< mplayer image format */
    bool use_textures;          /**< use 3D texture rendering, instead of
                                StretchRect */
    bool use_shaders;           /**< use shader for YUV color conversion
                                (or possibly for RGB video equalizers) */

    int plane_count;
    struct texplane planes[3];

    IDirect3DPixelShader9 *pixel_shader;
    const BYTE *pixel_shader_data;

    D3DFORMAT movie_src_fmt;        /**< Movie colorspace format (depends on
                                    the movie's codec) */
    D3DFORMAT desktop_fmt;          /**< Desktop (screen) colorspace format.
                                    Usually XRGB */

    HANDLE d3d9_dll;                /**< d3d9 Library HANDLE */
    IDirect3D9 * (WINAPI *pDirect3DCreate9)(UINT); /**< pointer to Direct3DCreate9 function */

    LPDIRECT3D9        d3d_handle;  /**< Direct3D Handle */
    LPDIRECT3DDEVICE9  d3d_device;  /**< The Direct3D Adapter */
    bool d3d_in_scene;              /**< BeginScene was called, EndScene not */
    IDirect3DSurface9 *d3d_surface; /**< Offscreen Direct3D Surface. MPlayer
                                    renders inside it. Uses colorspace
                                    priv->movie_src_fmt */
    struct d3dtex texture_osd;      /**< RGBA */
    IDirect3DSurface9 *d3d_backbuf; /**< Video card's back buffer (used to
                                    display next frame) */
    struct d3dtex texture_eosd;     /**< A8 */
    int cur_backbuf_width;          /**< Current backbuffer width */
    int cur_backbuf_height;         /**< Current backbuffer height */
    int is_osd_populated;           /**< 1 = OSD texture has something to display,
                                    0 = OSD texture is clear */
    int device_caps_power2_only;    /**< 1 = texture sizes have to be power 2
                                    0 = texture sizes can be anything */
    int device_caps_square_only;    /**< 1 = textures have to be square
                                    0 = textures do not have to be square */
    int device_texture_sys;         /**< 1 = device can texture from system memory
                                    0 = device requires shadow */
    int max_texture_width;          /**< from the device capabilities */
    int max_texture_height;         /**< from the device capabilities */

    D3DMATRIX d3d_colormatrix;
    struct mp_csp_details colorspace;
    struct mp_csp_equalizer video_eq;

    struct eosd_packer *eosd;       /**< EOSD packer (image positions etc.) */
    vertex_eosd *eosd_vb;           /**< temporary memory for D3D when rendering EOSD */
} d3d_priv;

struct fmt_entry {
    const unsigned int  mplayer_fmt;   /**< Given by MPlayer */
    const D3DFORMAT     fourcc;        /**< Required by D3D's test function */
};

/* Map table from reported MPlayer format to the required
   fourcc. This is needed to perform the format query. */

static const struct fmt_entry fmt_table[] = {
    // planar YUV
    {IMGFMT_YV12,  MAKEFOURCC('Y','V','1','2')},
    {IMGFMT_I420,  MAKEFOURCC('I','4','2','0')},
    {IMGFMT_IYUV,  MAKEFOURCC('I','Y','U','V')},
    {IMGFMT_YVU9,  MAKEFOURCC('Y','V','U','9')},
    // packed YUV
    {IMGFMT_YUY2,  D3DFMT_YUY2},
    {IMGFMT_UYVY,  D3DFMT_UYVY},
    // packed RGB
    {IMGFMT_BGR32, D3DFMT_X8R8G8B8},
    {IMGFMT_RGB32, D3DFMT_X8B8G8R8},
    {IMGFMT_BGR24, D3DFMT_R8G8B8}, //untested
    {IMGFMT_BGR16, D3DFMT_R5G6B5},
    {IMGFMT_BGR15, D3DFMT_X1R5G5B5},
    {IMGFMT_BGR8 , D3DFMT_R3G3B2}, //untested
    // grayscale (can be considered both packed and planar)
    {IMGFMT_Y8,    D3DFMT_L8},
    {IMGFMT_Y16,   D3DFMT_L16},
    {0},
};


typedef enum back_buffer_action {
    BACKBUFFER_CREATE,
    BACKBUFFER_RESET
} back_buffer_action_e;

static void generate_eosd(d3d_priv *priv, mp_eosd_images_t *);
static void draw_eosd(d3d_priv *priv);
static void update_colorspace(d3d_priv *priv);
static void d3d_clear_video_textures(d3d_priv *priv);
static int resize_d3d(d3d_priv *priv);
static uint32_t d3d_draw_frame(d3d_priv *priv);
static int draw_slice(struct vo *vo, uint8_t *src[], int stride[], int w, int h,
                      int x, int y);
static void uninit(struct vo *vo);
static void draw_osd(struct vo *vo, struct osd_state *osd);
static void flip_page(struct vo *vo);


static void d3d_matrix_identity(D3DMATRIX *m)
{
    memset(m, 0, sizeof(D3DMATRIX));
    m->_11 = m->_22 = m->_33 = m->_44 = 1.0f;
}

static void d3d_matrix_ortho(D3DMATRIX *m, float left, float right,
                             float bottom, float top)
{
    d3d_matrix_identity(m);
    m->_11 = 2.0f / (right - left);
    m->_22 = 2.0f / (top - bottom);
    m->_33 = 1.0f;
    m->_41 = -(right + left) / (right - left);
    m->_42 = -(top + bottom) / (top - bottom);
    m->_43 = 0;
    m->_44 = 1.0f;
}

/****************************************************************************
 *                                                                          *
 *                                                                          *
 *                                                                          *
 * Direct3D specific implementation functions                               *
 *                                                                          *
 *                                                                          *
 *                                                                          *
 ****************************************************************************/

static bool d3d_begin_scene(d3d_priv *priv)
{
    if (!priv->d3d_in_scene) {
        if (FAILED(IDirect3DDevice9_BeginScene(priv->d3d_device))) {
            mp_msg(MSGT_VO, MSGL_ERR, "<vo_direct3d>BeginScene failed.\n");
            return false;
        }
        priv->d3d_in_scene = true;
    }
    return true;
}

/** @brief Calculate scaled fullscreen movie rectangle with
 *  preserved aspect ratio.
 */
static void calc_fs_rect(d3d_priv *priv)
{
    struct vo_rect src_rect;
    struct vo_rect dst_rect;
    struct vo_rect borders;
    calc_src_dst_rects(priv->vo, priv->src_width, priv->src_height, &src_rect,
                       &dst_rect, &borders, NULL);

    priv->fs_movie_rect.left     = dst_rect.left;
    priv->fs_movie_rect.right    = dst_rect.right;
    priv->fs_movie_rect.top      = dst_rect.top;
    priv->fs_movie_rect.bottom   = dst_rect.bottom;
    priv->fs_panscan_rect.left   = src_rect.left;
    priv->fs_panscan_rect.right  = src_rect.right;
    priv->fs_panscan_rect.top    = src_rect.top;
    priv->fs_panscan_rect.bottom = src_rect.bottom;
    priv->border_x               = borders.left;
    priv->border_y               = borders.top;

    mp_msg(MSGT_VO, MSGL_V,
           "<vo_direct3d>Video rectangle: t: %ld, l: %ld, r: %ld, b:%ld\n",
           priv->fs_movie_rect.top,   priv->fs_movie_rect.left,
           priv->fs_movie_rect.right, priv->fs_movie_rect.bottom);

    /* The backbuffer should be cleared before next StretchRect. This is
     * necessary because our new draw area could be smaller than the
     * previous one used by StretchRect and without it, leftovers from the
     * previous frame will be left. */
    priv->is_clear_needed = 1;
}

// Adjust the texture size *width/*height to fit the requirements of the D3D
// device. The texture size is only increased.
static void d3d_fix_texture_size(d3d_priv *priv, int *width, int *height)
{
    int tex_width = *width;
    int tex_height = *height;

    // avoid nasty special cases with 0-sized textures and texture sizes
    tex_width = FFMAX(tex_width, 1);
    tex_height = FFMAX(tex_height, 1);

    if (priv->device_caps_power2_only) {
        tex_width  = 1;
        tex_height = 1;
        while (tex_width  < *width) tex_width  <<= 1;
        while (tex_height < *height) tex_height <<= 1;
    }
    if (priv->device_caps_square_only)
        /* device only supports square textures */
        tex_width = tex_height = FFMAX(tex_width, tex_height);
    // better round up to a multiple of 16
    if (!priv->opt_disable_texture_align) {
        tex_width  = (tex_width  + 15) & ~15;
        tex_height = (tex_height + 15) & ~15;
    }

    *width = tex_width;
    *height = tex_height;
}

static void d3dtex_release(d3d_priv *priv, struct d3dtex *tex)
{
    if (tex->system)
        IDirect3DTexture9_Release(tex->system);
    tex->system = NULL;

    if (tex->device)
        IDirect3DTexture9_Release(tex->device);
    tex->device = NULL;

    tex->tex_w = tex->tex_h = 0;
}

static bool d3dtex_allocate(d3d_priv *priv, struct d3dtex *tex, D3DFORMAT fmt,
                            int w, int h)
{
    d3dtex_release(priv, tex);

    tex->w = w;
    tex->h = h;

    int tw = w, th = h;
    d3d_fix_texture_size(priv, &tw, &th);

    if (FAILED(IDirect3DDevice9_CreateTexture(priv->d3d_device, tw, th, 1,
        D3DUSAGE_DYNAMIC, fmt, D3DPOOL_SYSTEMMEM, &tex->system, NULL)))
    {
        mp_msg(MSGT_VO, MSGL_ERR,
               "<vo_direct3d>Allocating %dx%d texture in system RAM failed.\n",
               w, h);
        goto error_exit;
    }

    if (!priv->device_texture_sys) {
        if (FAILED(IDirect3DDevice9_CreateTexture(priv->d3d_device, tw, th, 1,
            D3DUSAGE_DYNAMIC, fmt, D3DPOOL_DEFAULT, &tex->device, NULL)))
        {
            mp_msg(MSGT_VO, MSGL_ERR,
               "<vo_direct3d>Allocating %dx%d texture in video RAM failed.\n",
               w, h);
            goto error_exit;
        }
    }

    tex->tex_w = tw;
    tex->tex_h = th;

    return true;

error_exit:
    d3dtex_release(priv, tex);
    return false;
}

static IDirect3DBaseTexture9 *d3dtex_get_render_texture(d3d_priv *priv,
                                                        struct d3dtex *tex)
{
    return (IDirect3DBaseTexture9 *)(tex->device ? tex->device : tex->system);
}

// Copy system texture contents to device texture.
static bool d3dtex_update(d3d_priv *priv, struct d3dtex *tex)
{
    if (!tex->device)
        return true;
    return !FAILED(IDirect3DDevice9_UpdateTexture(priv->d3d_device,
                   (IDirect3DBaseTexture9 *)tex->system,
                   (IDirect3DBaseTexture9 *)tex->device));
}

static void d3d_unlock_video_objects(d3d_priv *priv)
{
    bool any_failed = false;

    if (priv->locked_rect.pBits) {
        if (FAILED(IDirect3DSurface9_UnlockRect(priv->d3d_surface)))
            any_failed = true;
    }
    priv->locked_rect.pBits = NULL;

    for (int n = 0; n < priv->plane_count; n++) {
        struct texplane *plane = &priv->planes[n];
        if (plane->locked_rect.pBits) {
            if (FAILED(IDirect3DTexture9_UnlockRect(plane->texture.system, 0)))
                any_failed = true;
        }
        plane->locked_rect.pBits = NULL;
    }

    if (any_failed) {
        mp_msg(MSGT_VO, MSGL_V,
               "<vo_direct3d>Unlocking video objects failed.\n");
    }
}

// Free video surface/textures, shaders, etc.
static void d3d_destroy_video_objects(d3d_priv *priv)
{
    d3d_unlock_video_objects(priv);

    if (priv->d3d_surface)
        IDirect3DSurface9_Release(priv->d3d_surface);
    priv->d3d_surface = NULL;

    for (int n = 0; n < priv->plane_count; n++) {
        d3dtex_release(priv, &priv->planes[n].texture);
    }

    if (priv->pixel_shader)
        IDirect3DPixelShader9_Release(priv->pixel_shader);
    priv->pixel_shader = NULL;
}

/** @brief Destroy D3D Offscreen and Backbuffer surfaces.
 */
static void destroy_d3d_surfaces(d3d_priv *priv)
{
    mp_msg(MSGT_VO, MSGL_V, "<vo_direct3d>destroy_d3d_surfaces called.\n");

    d3d_destroy_video_objects(priv);

    d3dtex_release(priv, &priv->texture_osd);

    if (priv->d3d_backbuf)
        IDirect3DSurface9_Release(priv->d3d_backbuf);
    priv->d3d_backbuf = NULL;

    d3dtex_release(priv, &priv->texture_eosd);

    if (priv->eosd)
        eosd_packer_reinit(priv->eosd, 0, 0);
}

// Allocate video surface or textures, and create shaders if needed.
static bool d3d_configure_video_objects(d3d_priv *priv)
{
    int n;
    bool need_clear = false;

    assert(priv->image_format != 0);

    if (priv->use_textures) {
        for (n = 0; n < priv->plane_count; n++) {
            struct texplane *plane = &priv->planes[n];

            if (!plane->texture.system) {
                if (!d3dtex_allocate(priv,
                                     &plane->texture,
                                     plane->d3d_format,
                                     priv->src_width >> plane->shift_x,
                                     priv->src_height >> plane->shift_y))
                {
                    mp_msg(MSGT_VO, MSGL_ERR, "<vo_direct3d>Allocating plane %d"
                           " failed.\n", n);
                    return false;
                }

                mp_msg(MSGT_VO, MSGL_V, "<vo_direct3d>Allocated plane %d:"
                       " %d bit, shift=%d/%d size=%d/%d (%d/%d).\n", n,
                       plane->bits_per_pixel,
                       plane->shift_x, plane->shift_y,
                       plane->texture.w, plane->texture.h,
                       plane->texture.tex_w, plane->texture.tex_h);

                need_clear = true;
            }
        }

        if (need_clear)
            d3d_clear_video_textures(priv);

        if (priv->pixel_shader_data) {
            if (!priv->pixel_shader &&
                FAILED(IDirect3DDevice9_CreatePixelShader(priv->d3d_device,
                    (DWORD *)priv->pixel_shader_data, &priv->pixel_shader)))
            {
                mp_msg(MSGT_VO, MSGL_ERR, "<vo_direct3d>Failed to create "
                       "YUV conversion pixel shader.\n");
                return false;
            }
        }

    } else {

        if (!priv->d3d_surface &&
            FAILED(IDirect3DDevice9_CreateOffscreenPlainSurface(
                priv->d3d_device, priv->src_width, priv->src_height,
                priv->movie_src_fmt, D3DPOOL_DEFAULT, &priv->d3d_surface, NULL)))
        {
            mp_msg(MSGT_VO, MSGL_ERR,
                "<vo_direct3d>Allocating offscreen surface failed.\n");
            return false;
        }
    }

    return true;
}

static bool d3d_lock_video_textures(d3d_priv *priv)
{
    for (int n = 0; n < priv->plane_count; n++) {
        struct texplane *plane = &priv->planes[n];

        if (!plane->locked_rect.pBits) {
            if (FAILED(IDirect3DTexture9_LockRect(plane->texture.system, 0,
                                                  &plane->locked_rect, NULL, 0)))
            {
                mp_msg(MSGT_VO, MSGL_V, "<vo_direct3d>Texture lock failure.\n");
                d3d_unlock_video_objects(priv);
                return false;
            }
        }
    }

    return true;
}

static void d3d_clear_video_textures(d3d_priv *priv)
{
    if (!d3d_lock_video_textures(priv))
        return;

    for (int n = 0; n < priv->plane_count; n++) {
        struct texplane *plane = &priv->planes[n];
        memset(plane->locked_rect.pBits, plane->clearval,
               plane->locked_rect.Pitch * plane->texture.tex_h);
    }

    d3d_unlock_video_objects(priv);
}

/** @brief Create D3D Offscreen and Backbuffer surfaces. Each
 *         surface is created only if it's not already present.
 *  @return 1 on success, 0 on failure
 */
static int create_d3d_surfaces(d3d_priv *priv)
{
    int osd_width = priv->vo->dwidth, osd_height = priv->vo->dheight;
    int tex_width = osd_width, tex_height = osd_height;
    mp_msg(MSGT_VO, MSGL_V, "<vo_direct3d>create_d3d_surfaces called.\n");

    if (!priv->d3d_backbuf &&
        FAILED(IDirect3DDevice9_GetBackBuffer(priv->d3d_device, 0, 0,
                                              D3DBACKBUFFER_TYPE_MONO,
                                              &priv->d3d_backbuf))) {
        mp_msg(MSGT_VO, MSGL_ERR, "<vo_direct3d>Allocating backbuffer failed.\n");
        return 0;
    }

    if (!d3d_configure_video_objects(priv))
        return 0;

    /* create OSD */

    d3d_fix_texture_size(priv, &tex_width, &tex_height);

    while (tex_width > priv->max_texture_width
           || tex_height > priv->max_texture_height)
    {
        osd_width  >>= 1;
        osd_height >>= 1;
        tex_width  >>= 1;
        tex_height >>= 1;
    }

    if (priv->texture_osd.tex_w < tex_width
        || priv->texture_osd.tex_h < tex_height)
    {
        d3dtex_release(priv, &priv->texture_osd);

        mp_msg(MSGT_VO, MSGL_V, "<vo_direct3d>OSD texture size (%dx%d),"
               " requested (%dx%d).\n", osd_width, osd_height, tex_width,
               tex_height);

        if (!d3dtex_allocate(priv, &priv->texture_osd, D3DFMT_A8L8, tex_width,
                             tex_height))
        {
            mp_msg(MSGT_VO, MSGL_ERR,
                "<vo_direct3d>Allocating OSD texture failed.\n");
            return 0;
        }
    }

    priv->texture_osd.w = osd_width;
    priv->texture_osd.h = osd_height;

    /* setup default renderstate */
    IDirect3DDevice9_SetRenderState(priv->d3d_device,
                                    D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
    IDirect3DDevice9_SetRenderState(priv->d3d_device,
                                    D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
    IDirect3DDevice9_SetRenderState(priv->d3d_device,
                                    D3DRS_ALPHAFUNC, D3DCMP_GREATER);
    IDirect3DDevice9_SetRenderState(priv->d3d_device,
                                    D3DRS_ALPHAREF, (DWORD)0x0);
    IDirect3DDevice9_SetRenderState(priv->d3d_device,
                                    D3DRS_LIGHTING, FALSE);

    // we use up to 3 samplers for up to 3 YUV planes
    for (int n = 0; n < 3; n++) {
        IDirect3DDevice9_SetSamplerState(priv->d3d_device, n, D3DSAMP_MINFILTER,
                                         D3DTEXF_LINEAR);
        IDirect3DDevice9_SetSamplerState(priv->d3d_device, n, D3DSAMP_MAGFILTER,
                                         D3DTEXF_LINEAR);
        IDirect3DDevice9_SetSamplerState(priv->d3d_device, n, D3DSAMP_ADDRESSU,
                                         D3DTADDRESS_CLAMP);
        IDirect3DDevice9_SetSamplerState(priv->d3d_device, n, D3DSAMP_ADDRESSV,
                                         D3DTADDRESS_CLAMP);
    }

    if (priv->eosd && !priv->texture_eosd.system)
        eosd_packer_reinit(priv->eosd, priv->max_texture_width,
                           priv->max_texture_height);

    return 1;
}

/** @brief Fill D3D Presentation parameters
 */
static void fill_d3d_presentparams(d3d_priv *priv,
                                   D3DPRESENT_PARAMETERS *present_params)
{
    /* Prepare Direct3D initialization parameters. */
    memset(present_params, 0, sizeof(D3DPRESENT_PARAMETERS));
    present_params->Windowed               = TRUE;
    present_params->SwapEffect             = D3DSWAPEFFECT_COPY;
    present_params->Flags                  = D3DPRESENTFLAG_VIDEO;
    present_params->hDeviceWindow          = vo_w32_window; /* w32_common var */
    present_params->BackBufferWidth        = priv->cur_backbuf_width;
    present_params->BackBufferHeight       = priv->cur_backbuf_height;
    present_params->MultiSampleType        = D3DMULTISAMPLE_NONE;
    present_params->PresentationInterval   = D3DPRESENT_INTERVAL_ONE;
    present_params->BackBufferFormat       = priv->desktop_fmt;
    present_params->BackBufferCount        = 1;
    present_params->EnableAutoDepthStencil = FALSE;
}


/** @brief Create a new backbuffer. Create or Reset the D3D
 *         device.
 *  @return 1 on success, 0 on failure
 */
static int change_d3d_backbuffer(d3d_priv *priv, back_buffer_action_e action)
{
    D3DPRESENT_PARAMETERS present_params;

    destroy_d3d_surfaces(priv);

    int window_w = priv->vo->dwidth;
    int window_h = priv->vo->dheight;

    /* Grow the backbuffer in the required dimension. */
    if (window_w > priv->cur_backbuf_width)
        priv->cur_backbuf_width = window_w;

    if (window_h > priv->cur_backbuf_height)
        priv->cur_backbuf_height = window_h;

    /* The grown backbuffer dimensions are ready and fill_d3d_presentparams
     * will use them, so we can reset the device.
     */
    fill_d3d_presentparams(priv, &present_params);

    /* vo_w32_window is w32_common variable. It's a handle to the window. */
    if (action == BACKBUFFER_CREATE &&
        FAILED(IDirect3D9_CreateDevice(priv->d3d_handle,
                                       D3DADAPTER_DEFAULT,
                                       DEVTYPE, vo_w32_window,
                                       D3DCREATE_SOFTWARE_VERTEXPROCESSING,
                                       &present_params, &priv->d3d_device))) {
            mp_msg(MSGT_VO, MSGL_V,
                   "<vo_direct3d>Creating Direct3D device failed.\n");
        return 0;
    }

    if (action == BACKBUFFER_RESET &&
        FAILED(IDirect3DDevice9_Reset(priv->d3d_device, &present_params))) {
            mp_msg(MSGT_VO, MSGL_ERR,
                   "<vo_direct3d>Reseting Direct3D device failed.\n");
        return 0;
    }

    mp_msg(MSGT_VO, MSGL_V,
           "<vo_direct3d>New backbuffer (%dx%d), VO (%dx%d)\n",
           present_params.BackBufferWidth, present_params.BackBufferHeight,
           window_w, window_h);

    return 1;
}

/** @brief Configure initial Direct3D context. The first
 *  function called to initialize the D3D context.
 *  @return 1 on success, 0 on failure
 */
static int configure_d3d(d3d_priv *priv)
{
    D3DDISPLAYMODE disp_mode;

    mp_msg(MSGT_VO, MSGL_V, "<vo_direct3d>configure_d3d called.\n");

    destroy_d3d_surfaces(priv);

    /* Get the current desktop display mode, so we can set up a back buffer
     * of the same format. */
    if (FAILED(IDirect3D9_GetAdapterDisplayMode(priv->d3d_handle,
                                                D3DADAPTER_DEFAULT,
                                                &disp_mode))) {
        mp_msg(MSGT_VO, MSGL_ERR,
               "<vo_direct3d>Reading adapter display mode failed.\n");
        return 0;
    }

    priv->desktop_fmt = disp_mode.Format;

    if (!change_d3d_backbuffer(priv, BACKBUFFER_CREATE))
        return 0;

    if (!create_d3d_surfaces(priv))
        return 0;

    resize_d3d(priv);

    return 1;
}

/** @brief Reconfigure the whole Direct3D. Called only
 *  when the video adapter becomes uncooperative.
 *  @return 1 on success, 0 on failure
 */
static int reconfigure_d3d(d3d_priv *priv)
{
    mp_msg(MSGT_VO, MSGL_V, "<vo_direct3d>reconfigure_d3d called.\n");

    destroy_d3d_surfaces(priv);

    if (priv->d3d_device)
        IDirect3DDevice9_Release(priv->d3d_device);
    priv->d3d_device = NULL;

    IDirect3D9_Release(priv->d3d_handle);

    priv->d3d_handle = priv->pDirect3DCreate9(D3D_SDK_VERSION);
    if (!priv->d3d_handle) {
        mp_msg(MSGT_VO, MSGL_ERR, "<vo_direct3d>Initializing Direct3D failed.\n");
        return 0;
    }

    if (!configure_d3d(priv))
        return 0;

    return 1;
}

/** @brief Resize Direct3D context on window resize.
 *  @return 1 on success, 0 on failure
 */
static int resize_d3d(d3d_priv *priv)
{
    D3DVIEWPORT9 vp = {0, 0, priv->vo->dwidth, priv->vo->dheight, 0, 1};

    mp_msg(MSGT_VO, MSGL_V, "<vo_direct3d>resize_d3d called.\n");

    /* Make sure that backbuffer is large enough to accomodate the new
       viewport dimensions. Grow it if necessary. */

    if (priv->vo->dwidth > priv->cur_backbuf_width ||
        priv->vo->dheight > priv->cur_backbuf_height)
    {
        if (!change_d3d_backbuffer(priv, BACKBUFFER_RESET))
            return 0;
    }

    /* Recreate the OSD. The function will observe that the offscreen plain
     * surface and the backbuffer are not destroyed and will skip their creation,
     * effectively recreating only the OSD.
     */

    if (!create_d3d_surfaces(priv))
        return 0;

    if (FAILED(IDirect3DDevice9_SetViewport(priv->d3d_device, &vp))) {
        mp_msg(MSGT_VO, MSGL_ERR, "<vo_direct3d>Setting viewport failed.\n");
        return 0;
    }

    // so that screen coordinates map to D3D ones
    D3DMATRIX view;
    d3d_matrix_ortho(&view, 0.5f, vp.Width + 0.5f, vp.Height + 0.5f, 0.5f);
    IDirect3DDevice9_SetTransform(priv->d3d_device, D3DTS_VIEW, &view);

    calc_fs_rect(priv);

#ifdef CONFIG_FREETYPE
    // font needs to be adjusted
    force_load_font = 1;
#endif
    // OSD needs to be drawn fresh for new size
    vo_osd_changed(OSDTYPE_OSD);

    priv->vo->want_redraw = true;

    return 1;
}

/** @brief Uninitialize Direct3D and close the window.
 */
static void uninit_d3d(d3d_priv *priv)
{
    mp_msg(MSGT_VO, MSGL_V, "<vo_direct3d>uninit_d3d called.\n");

    destroy_d3d_surfaces(priv);

    if (priv->d3d_device)
        IDirect3DDevice9_Release(priv->d3d_device);
    priv->d3d_device = NULL;

    if (priv->d3d_handle) {
        mp_msg(MSGT_VO, MSGL_V, "<vo_direct3d>Stopping Direct3D.\n");
        IDirect3D9_Release(priv->d3d_handle);
    }
    priv->d3d_handle = NULL;
}

static uint32_t d3d_upload_and_render_frame_texture(d3d_priv *priv,
                                                    mp_image_t *mpi)
{
    if (!(mpi->flags & MP_IMGFLAG_DRAW_CALLBACK))
        draw_slice(priv->vo, mpi->planes, mpi->stride, mpi->w, mpi->h, 0, 0);

    d3d_unlock_video_objects(priv);

    for (int n = 0; n < priv->plane_count; n++) {
        d3dtex_update(priv, &priv->planes[n].texture);
    }

    return d3d_draw_frame(priv);
}

/** @brief Render a frame on the screen.
 *  @param mpi mpi structure with the decoded frame inside
 *  @return VO_TRUE on success, VO_ERROR on failure
 */
static uint32_t d3d_upload_and_render_frame(d3d_priv *priv, mp_image_t *mpi)
{
    /* If the D3D device is uncooperative (not initialized), return success.
       The device will be probed for reinitialization in the next flip_page() */
    if (!priv->d3d_device)
        return VO_TRUE;

    if (priv->use_textures)
        return d3d_upload_and_render_frame_texture(priv, mpi);

    if (mpi->flags & MP_IMGFLAG_DRAW_CALLBACK)
        goto skip_upload;

    if (mpi->flags & MP_IMGFLAG_PLANAR) { /* Copy a planar frame. */
        draw_slice(priv->vo, mpi->planes, mpi->stride, mpi->w, mpi->h, 0, 0);
        goto skip_upload;
    }

    /* If we're here, then we should lock the rect and copy a packed frame */
    if (!priv->locked_rect.pBits) {
        if (FAILED(IDirect3DSurface9_LockRect(priv->d3d_surface,
                                              &priv->locked_rect, NULL, 0))) {
            mp_msg(MSGT_VO, MSGL_ERR, "<vo_direct3d>Surface lock failed.\n");
            return VO_ERROR;
        }
    }

    memcpy_pic(priv->locked_rect.pBits, mpi->planes[0], mpi->stride[0],
               mpi->height, priv->locked_rect.Pitch, mpi->stride[0]);

skip_upload:
    d3d_unlock_video_objects(priv);

    return d3d_draw_frame(priv);
}

static uint32_t d3d_draw_frame(d3d_priv *priv)
{
    int n;

    if (!d3d_begin_scene(priv))
        return VO_ERROR;

    if (priv->is_clear_needed) {
        IDirect3DDevice9_Clear(priv->d3d_device, 0, NULL,
                               D3DCLEAR_TARGET, 0, 0, 0);
        priv->is_clear_needed = 0;
    }

    if (priv->use_textures) {

        for (n = 0; n < priv->plane_count; n++) {
            IDirect3DDevice9_SetTexture(priv->d3d_device, n,
                d3dtex_get_render_texture(priv, &priv->planes[n].texture));
        }

        RECT rm = priv->fs_movie_rect;
        RECT rs = priv->fs_panscan_rect;

        vertex_video vb[] = {
            { rm.left,  rm.top,    0.0f},
            { rm.right, rm.top,    0.0f},
            { rm.left,  rm.bottom, 0.0f},
            { rm.right, rm.bottom, 0.0f}
        };

        float texc[4][2] = {
            { rs.left,  rs.top},
            { rs.right, rs.top},
            { rs.left,  rs.bottom},
            { rs.right, rs.bottom}
        };

        for (n = 0; n < priv->plane_count; n++) {
            float s_x = (1.0f / (1 << priv->planes[n].shift_x))
                        / priv->planes[n].texture.tex_w;
            float s_y = (1.0f / (1 << priv->planes[n].shift_y))
                        / priv->planes[n].texture.tex_h;
            for (int i = 0; i < 4; i++) {
                vb[i].t[n][0] = texc[i][0] * s_x;
                vb[i].t[n][1] = texc[i][1] * s_y;
            }
        }

        if (priv->pixel_shader) {
            IDirect3DDevice9_SetPixelShader(priv->d3d_device, priv->pixel_shader);
            IDirect3DDevice9_SetPixelShaderConstantF(priv->d3d_device, 0,
                                                     &priv->d3d_colormatrix._11,
                                                     4);
        }

        IDirect3DDevice9_SetFVF(priv->d3d_device, D3DFVF_VIDEO_VERTEX);
        IDirect3DDevice9_DrawPrimitiveUP(priv->d3d_device, D3DPT_TRIANGLESTRIP,
                                         2, &vb[0], sizeof(vertex_video));

        IDirect3DDevice9_SetPixelShader(priv->d3d_device, NULL);

        for (n = 0; n < priv->plane_count; n++) {
            IDirect3DDevice9_SetTexture(priv->d3d_device, n, NULL);
        }

    } else {
        if (FAILED(IDirect3DDevice9_StretchRect(priv->d3d_device,
                                                priv->d3d_surface,
                                                &priv->fs_panscan_rect,
                                                priv->d3d_backbuf,
                                                &priv->fs_movie_rect,
                                                D3DTEXF_LINEAR))) {
            mp_msg(MSGT_VO, MSGL_ERR,
                "<vo_direct3d>Copying frame to the backbuffer failed.\n");
            return VO_ERROR;
        }
    }

    return VO_TRUE;
}

// Return the high byte of the value that represents white in chroma (U/V)
static int get_chroma_clear_val(int bit_depth)
{
    return 1 << (bit_depth - 1 & 7);
}

// this macro is supposed to work on all formats supported by 3D rendering, and
// that produce "reasonable" output (i.e. no mixed up colors)
#define IMGFMT_IS_ANY_RND(x) \
    (IMGFMT_IS_BGR(x) || IMGFMT_IS_RGB(x) || IMGFMT_IS_Y(x))

// pixel size in bit for any IMGFMT_IS_ANY_RND(x)==true
// we assume that the actual pixel strides are always aligned on bytes
static int imgfmt_any_rnd_depth(int fmt)
{
    if (IMGFMT_IS_BGR(fmt))
        return IMGFMT_BGR_DEPTH(fmt);
    if (IMGFMT_IS_RGB(fmt))
        return IMGFMT_RGB_DEPTH(fmt);
    if (IMGFMT_IS_Y(fmt))
        return IMGFMT_Y_DEPTH(fmt);
    assert(false);
    return 0;
}

static D3DFORMAT check_format(d3d_priv *priv, uint32_t movie_fmt,
                              bool as_texture)
{
    const char *type = as_texture ? "texture rendering" : "StretchRect";
    const struct fmt_entry *cur = &fmt_table[0];

    // Don't try to handle weird packed texture formats (although I don't know
    // if D3D9 would even accept any such format for 3D rendering; and we
    // certainly don't try any tricks like matching it to RGB formats and
    // applying a YUV conversion matrix)
    if (as_texture && !IMGFMT_IS_ANY_RND(movie_fmt))
        return 0;

    while (cur->mplayer_fmt) {
        if (cur->mplayer_fmt == movie_fmt) {
            HRESULT res;
            if (as_texture) {
                res = IDirect3D9_CheckDeviceFormat(priv->d3d_handle,
                            D3DADAPTER_DEFAULT,
                            DEVTYPE,
                            priv->desktop_fmt,
                            D3DUSAGE_DYNAMIC | D3DUSAGE_QUERY_FILTER,
                            D3DRTYPE_TEXTURE,
                            cur->fourcc);
            } else {
                /* Test conversion from Movie colorspace to
                * display's target colorspace. */
                res = IDirect3D9_CheckDeviceFormatConversion(priv->d3d_handle,
                            D3DADAPTER_DEFAULT,
                            DEVTYPE,
                            cur->fourcc,
                            priv->desktop_fmt);
            }
            if (FAILED(res)) {
                mp_msg(MSGT_VO, MSGL_V, "<vo_direct3d>Rejected image format "
                       "(%s): %s\n", type, vo_format_name(cur->mplayer_fmt));
                return 0;
            }

            mp_msg(MSGT_VO, MSGL_DBG2, "<vo_direct3d>Accepted image format "
                   "(%s): %s\n", type, vo_format_name(cur->mplayer_fmt));

            return cur->fourcc;
        }
        cur++;
    }

    return 0;
}

// Check whether YUV conversion with shaders can be done.
// Returns the format the individual planes should use (or 0 on failure)
static D3DFORMAT check_shader_conversion(d3d_priv *priv, uint32_t fmt)
{
    if (priv->opt_disable_shaders)
        return 0;
    int component_bits;
    if (!mp_get_chroma_shift(fmt, NULL, NULL, &component_bits))
        return 0;
    if (component_bits < 8 || component_bits > 16)
        return 0;
    bool is_8bit = component_bits == 8;
    if (!is_8bit && priv->opt_only_8bit)
        return 0;
    return check_format(priv, is_8bit ? IMGFMT_Y8 : IMGFMT_Y16, true);
}

// Return if the image format can be used. If it can, decide which rendering
// and conversion mode to use.
// If initialize is true, actually setup all variables to use the picked
// rendering mode.
static bool init_rendering_mode(d3d_priv *priv, uint32_t fmt, bool initialize)
{
    int n;
    int blit_d3dfmt = check_format(priv, fmt, false);
    int texture_d3dfmt = check_format(priv, fmt, true);
    int shader_d3dfmt = check_shader_conversion(priv, fmt);

    if (priv->opt_disable_textures)
        texture_d3dfmt = 0;
    if (priv->opt_disable_shaders)
        shader_d3dfmt = 0;
    if (priv->opt_disable_stretchrect)
        blit_d3dfmt = 0;

    if (!(blit_d3dfmt || shader_d3dfmt || texture_d3dfmt))
        return false;

    mp_msg(MSGT_VO, MSGL_V, "<vo_direct3d>Accepted rendering methods for "
           "format='%s': StretchRect=%#x, Texture=%#x, Texture+Shader=%#x.\n",
           vo_format_name(fmt), blit_d3dfmt, texture_d3dfmt, shader_d3dfmt);

    if (!initialize)
        return true;

    // initialization doesn't fail beyond this point

    priv->use_shaders = false;
    priv->use_textures = false;
    priv->movie_src_fmt = 0;
    priv->pixel_shader_data = NULL;
    priv->plane_count = 0;
    priv->image_format = fmt;

    if (blit_d3dfmt && priv->opt_prefer_stretchrect)
        texture_d3dfmt = shader_d3dfmt = 0;

    if (texture_d3dfmt) {
        priv->use_textures = true;
    } else if (shader_d3dfmt) {
        priv->use_textures = true;
        priv->use_shaders = true;
    } else {
        assert(!!blit_d3dfmt);
    }

    if (priv->use_textures) {
        mp_msg(MSGT_VO, MSGL_V, "<vo_direct3d>Using 3D rendering.\n");

        struct texplane *planes = &priv->planes[0];
        planes[0].shift_x = planes[0].shift_y = 0;
        planes[0].clearval = 0;

        if (!priv->use_shaders) {
            assert(IMGFMT_IS_ANY_RND(priv->image_format));
            priv->plane_count = 1;
            planes[0].bits_per_pixel = imgfmt_any_rnd_depth(priv->image_format);
            planes[0].d3d_format = texture_d3dfmt;
        } else {
            mp_msg(MSGT_VO, MSGL_V, "<vo_direct3d>Using YUV shaders.\n");

            int sx, sy, component_bits;
            mp_get_chroma_shift(priv->image_format, &sx, &sy, &component_bits);
            priv->plane_count = 3;
            for (n = 0; n < 3; n++) {
                planes[n].d3d_format = shader_d3dfmt;
                planes[n].bits_per_pixel = component_bits;
                if (n > 0) {
                    planes[n].shift_x = sx;
                    planes[n].shift_y = sy;
                    planes[n].clearval = get_chroma_clear_val(component_bits);
                }
            }
            priv->pixel_shader_data = d3d_shader_yuv;
        }

        for (n = 0; n < priv->plane_count; n++) {
            planes[n].bytes_per_pixel = (planes[n].bits_per_pixel + 7) / 8;
        }

    } else {
        mp_msg(MSGT_VO, MSGL_V, "<vo_direct3d>Using StretchRect.\n");

        priv->movie_src_fmt = blit_d3dfmt;
    }

    update_colorspace(priv);

    return true;
}

/** @brief Query if movie colorspace is supported by the HW.
 *  @return 0 on failure, device capabilities (not probed
 *          currently) on success.
 */
static int query_format(d3d_priv *priv, uint32_t movie_fmt)
{
    if (!init_rendering_mode(priv, movie_fmt, false))
        return 0;

    int eosd_caps = VFCAP_CSP_SUPPORTED | VFCAP_CSP_SUPPORTED_BY_HW
                    | VFCAP_OSD | VFCAP_HWSCALE_UP | VFCAP_HWSCALE_DOWN;
    if (priv->eosd)
        eosd_caps |= VFCAP_EOSD | VFCAP_EOSD_UNSCALED;
    return eosd_caps;
}

/****************************************************************************
 *                                                                          *
 *                                                                          *
 *                                                                          *
 * libvo Control / Callback functions                                       *
 *                                                                          *
 *                                                                          *
 *                                                                          *
 ****************************************************************************/

static void update_colorspace(d3d_priv *priv)
{
    float coeff[3][4];
    struct mp_csp_params csp = { .colorspace = priv->colorspace };
    mp_csp_copy_equalizer_values(&csp, &priv->video_eq);

    if (priv->use_shaders) {
        csp.input_shift = -priv->planes[0].bits_per_pixel & 7;
    }

    mp_get_yuv2rgb_coeffs(&csp, coeff);
    for (int row = 0; row < 3; row++) {
        for (int col = 0; col < 4; col++) {
            priv->d3d_colormatrix.m[row][col] = coeff[row][col];
        }
    }
}

const char *options_help_text = "-vo direct3d command line help:\n"
"Example: -vo direct3d:disable-eosd:disable-textures\n"
"Options:\n"
"    prefer-stretchrect\n"
"        Use IDirect3DDevice9::StretchRect over other methods if possible.\n"
"    disable-stretchrect\n"
"        Never render the video using IDirect3DDevice9::StretchRect.\n"
"    disable-textures\n"
"        Never render the video using D3D texture rendering. (Rendering with\n"
"        textures + shader will still be allowed. Add disable-shaders to\n"
"        completely disable video rendering with textures.)\n"
"    disable-shaders\n"
"        Never use shaders when rendering video.\n"
"    only-8bit\n"
"        Never render YUV video with more than 8 bits per component.\n"
"        (Using this flag will force software conversion to 8 bit.)\n"
"    disable-eosd\n"
"        Disable EOSD rendering for subtitles.\n"
"        (Using this flag might force the insertion of the 'ass' video filter,\n"
"         which will render the subtitles in software.)\n"
"    force-power-of-2\n"
"        Always force textures to power of 2, even if the device reports\n"
"        non-power-of-2 texture sizes as supported.\n"
"    disable-texture-align\n"
"        Normally texture sizes are always aligned to 16. With this option\n"
"        enabled, the video texture will always have exactly the same size as\n"
"        the video itself.\n";

/** @brief libvo Callback: Preinitialize the video card.
 *  Preinit the hardware just enough to be queried about
 *  supported formats.
 *
 *  @return 0 on success, -1 on failure
 */

static int preinit_internal(struct vo *vo, const char *arg, bool allow_shaders)
{
    D3DDISPLAYMODE disp_mode;
    D3DCAPS9 disp_caps;
    DWORD texture_caps;
    DWORD dev_caps;

    d3d_priv *priv = talloc_zero(vo, d3d_priv);
    vo->priv = priv;

    *priv = (d3d_priv) {
        .vo = vo,

        .colorspace = MP_CSP_DETAILS_DEFAULTS,
        .video_eq = { MP_CSP_EQ_CAPS_COLORMATRIX },
    };

    if (!allow_shaders) {
        priv->opt_disable_shaders = priv->opt_disable_textures = true;
    }

    int opt_force_power_of_2 = false;

    const opt_t subopts[] = {
        {"prefer-stretchrect", OPT_ARG_BOOL, &priv->opt_prefer_stretchrect},
        {"disable-textures", OPT_ARG_BOOL, &priv->opt_disable_textures},
        {"disable-stretchrect", OPT_ARG_BOOL, &priv->opt_disable_stretchrect},
        {"disable-shaders", OPT_ARG_BOOL, &priv->opt_disable_shaders},
        {"only-8bit", OPT_ARG_BOOL, &priv->opt_only_8bit},
        {"disable-eosd", OPT_ARG_BOOL, &priv->opt_disable_eosd},
        {"force-power-of-2", OPT_ARG_BOOL, &opt_force_power_of_2},
        {"disable-texture-align", OPT_ARG_BOOL, &priv->opt_disable_texture_align},
        {NULL}
    };
    if (subopt_parse(arg, subopts) != 0) {
        mp_msg(MSGT_VO, MSGL_FATAL, options_help_text);
        return -1;
    }

    if (!priv->opt_disable_eosd)
        priv->eosd = eosd_packer_create(priv);

    priv->d3d9_dll = LoadLibraryA("d3d9.dll");
    if (!priv->d3d9_dll) {
        mp_msg(MSGT_VO, MSGL_ERR,
               "<vo_direct3d>Unable to dynamically load d3d9.dll\n");
        goto err_out;
    }

    priv->pDirect3DCreate9 = (void *)GetProcAddress(priv->d3d9_dll,
                                                    "Direct3DCreate9");
    if (!priv->pDirect3DCreate9) {
        mp_msg(MSGT_VO, MSGL_ERR,
               "<vo_direct3d>Unable to find entry point of Direct3DCreate9\n");
        goto err_out;
    }

    priv->d3d_handle = priv->pDirect3DCreate9(D3D_SDK_VERSION);
    if (!priv->d3d_handle) {
        mp_msg(MSGT_VO, MSGL_ERR,
               "<vo_direct3d>Initializing Direct3D failed.\n");
        goto err_out;
    }

    if (FAILED(IDirect3D9_GetAdapterDisplayMode(priv->d3d_handle,
                                                D3DADAPTER_DEFAULT,
                                                &disp_mode))) {
        mp_msg(MSGT_VO, MSGL_ERR,
               "<vo_direct3d>Reading display mode failed.\n");
        goto err_out;
    }

    priv->desktop_fmt = disp_mode.Format;
    priv->cur_backbuf_width = disp_mode.Width;
    priv->cur_backbuf_height = disp_mode.Height;

    mp_msg(MSGT_VO, MSGL_V,
           "<vo_direct3d>Setting backbuffer dimensions to (%dx%d).\n",
           disp_mode.Width, disp_mode.Height);

    if (FAILED(IDirect3D9_GetDeviceCaps(priv->d3d_handle,
                                        D3DADAPTER_DEFAULT,
                                        DEVTYPE,
                                        &disp_caps)))
    {
        mp_msg(MSGT_VO, MSGL_ERR,
               "<vo_direct3d>Reading display capabilities failed.\n");
        goto err_out;
    }

    /* Store relevant information reguarding caps of device */
    texture_caps                  = disp_caps.TextureCaps;
    dev_caps                      = disp_caps.DevCaps;
    priv->device_caps_power2_only =  (texture_caps & D3DPTEXTURECAPS_POW2) &&
                        !(texture_caps & D3DPTEXTURECAPS_NONPOW2CONDITIONAL);
    priv->device_caps_square_only = texture_caps & D3DPTEXTURECAPS_SQUAREONLY;
    priv->device_texture_sys      = dev_caps & D3DDEVCAPS_TEXTURESYSTEMMEMORY;
    priv->max_texture_width       = disp_caps.MaxTextureWidth;
    priv->max_texture_height      = disp_caps.MaxTextureHeight;

    if (opt_force_power_of_2)
        priv->device_caps_power2_only = 1;

    mp_msg(MSGT_VO, MSGL_V,
           "<vo_direct3d>device_caps_power2_only %d, device_caps_square_only %d\n"
           "<vo_direct3d>device_texture_sys %d\n"
           "<vo_direct3d>max_texture_width %d, max_texture_height %d\n",
           priv->device_caps_power2_only, priv->device_caps_square_only,
           priv->device_texture_sys, priv->max_texture_width,
           priv->max_texture_height);

    /* w32_common framework call. Configures window on the screen, gets
     * fullscreen dimensions and does other useful stuff.
     */
    global_vo = vo;
    if (!vo_w32_init()) {
        mp_msg(MSGT_VO, MSGL_V,
               "<vo_direct3d>Configuring onscreen window failed.\n");
        goto err_out;
    }

    return 0;

err_out:
    uninit(vo);
    return -1;
}

static int preinit_standard(struct vo *vo, const char *arg)
{
    return preinit_internal(vo, arg, false);
}

static int preinit_shaders(struct vo *vo, const char *arg)
{
    return preinit_internal(vo, arg, true);
}

/** @brief libvo Callback: Handle control requests.
 *  @return VO_TRUE on success, VO_NOTIMPL when not implemented
 */
static int control(struct vo *vo, uint32_t request, void *data)
{
    d3d_priv *priv = vo->priv;

    switch (request) {
    case VOCTRL_QUERY_FORMAT:
        return query_format(priv, *(uint32_t*) data);
    case VOCTRL_GET_IMAGE:
        mp_msg(MSGT_VO, MSGL_V,
               "<vo_direct3d>Direct Rendering request. Not implemented yet.\n");
        return VO_NOTIMPL;
    case VOCTRL_DRAW_IMAGE:
        return d3d_upload_and_render_frame(priv, data);
    case VOCTRL_FULLSCREEN:
        vo_w32_fullscreen();
        resize_d3d(priv);
        return VO_TRUE;
    case VOCTRL_RESET:
        return VO_NOTIMPL;
    case VOCTRL_REDRAW_FRAME:
        priv->is_clear_needed = 1;
        d3d_draw_frame(priv);
        return VO_TRUE;
    case VOCTRL_SET_YUV_COLORSPACE:
        priv->colorspace = *(struct mp_csp_details *)data;
        update_colorspace(priv);
        vo->want_redraw = true;
        return VO_TRUE;
    case VOCTRL_GET_YUV_COLORSPACE:
        if (!priv->use_shaders)
            break; // no idea what the heck D3D YUV uses
        *(struct mp_csp_details *)data = priv->colorspace;
        return VO_TRUE;
    case VOCTRL_SET_EQUALIZER: {
        if (!priv->use_shaders)
            break;
        struct voctrl_set_equalizer_args *args = data;
        if (mp_csp_equalizer_set(&priv->video_eq, args->name, args->value) < 0)
            return VO_NOTIMPL;
        update_colorspace(priv);
        vo->want_redraw = true;
        return VO_TRUE;
    }
    case VOCTRL_GET_EQUALIZER: {
        if (!priv->use_shaders)
            break;
        struct voctrl_get_equalizer_args *args = data;
        return mp_csp_equalizer_get(&priv->video_eq, args->name, args->valueptr)
               >= 0 ? VO_TRUE : VO_NOTIMPL;
    }
    case VOCTRL_ONTOP:
        vo_w32_ontop();
        return VO_TRUE;
    case VOCTRL_BORDER:
        vo_w32_border();
        resize_d3d(priv);
        return VO_TRUE;
    case VOCTRL_UPDATE_SCREENINFO:
        w32_update_xinerama_info();
        return VO_TRUE;
    case VOCTRL_SET_PANSCAN:
        resize_d3d(priv);
        return VO_TRUE;
    case VOCTRL_GET_PANSCAN:
        return VO_TRUE;
    case VOCTRL_DRAW_EOSD:
        if (!data)
            return VO_FALSE;
        assert(priv->eosd);
        generate_eosd(priv, data);
        draw_eosd(priv);
        return VO_TRUE;
    case VOCTRL_GET_EOSD_RES: {
        assert(priv->eosd);
        struct mp_eosd_res *r = data;
        r->w = vo->dwidth;
        r->h = vo->dheight;
        r->ml = r->mr = priv->border_x;
        r->mt = r->mb = priv->border_y;
        return VO_TRUE;
    }
    }
    return VO_NOTIMPL;
}

/** @brief libvo Callback: Configre the Direct3D adapter.
 *  @param width    Movie source width
 *  @param height   Movie source height
 *  @param d_width  Screen (destination) width
 *  @param d_height Screen (destination) height
 *  @param options  Options bitmap
 *  @param format   Movie colorspace format (using MPlayer's
 *                  defines, e.g. IMGFMT_YUY2)
 *  @return 0 on success, VO_ERROR on failure
 */
static int config(struct vo *vo, uint32_t width, uint32_t height,
                  uint32_t d_width, uint32_t d_height, uint32_t options,
                  uint32_t format)
{
    d3d_priv *priv = vo->priv;

    /* w32_common framework call. Creates window on the screen with
     * the given coordinates.
     */
    if (!vo_w32_config(d_width, d_height, options)) {
        mp_msg(MSGT_VO, MSGL_V, "<vo_direct3d>Creating window failed.\n");
        return VO_ERROR;
    }

    if ((priv->image_format != format)
        || (priv->src_width != width)
        || (priv->src_height != height))
    {
        d3d_destroy_video_objects(priv);

        priv->src_width = width;
        priv->src_height = height;
        init_rendering_mode(priv, format, true);
    }

    if (!priv->d3d_device) {
        if (!configure_d3d(priv))
            return VO_ERROR;
    } else {
        if (!resize_d3d(priv))
            return VO_ERROR;
    }

    return 0; /* Success */
}

/** @brief libvo Callback: Flip next already drawn frame on the
 *         screen.
 */
static void flip_page(struct vo *vo)
{
    d3d_priv *priv = vo->priv;

    if (priv->d3d_in_scene) {
        if (FAILED(IDirect3DDevice9_EndScene(priv->d3d_device))) {
            mp_msg(MSGT_VO, MSGL_ERR, "<vo_direct3d>EndScene failed.\n");
        }
        priv->d3d_in_scene = false;
    }

    RECT rect = {0, 0, vo->dwidth, vo->dheight};
    if (!priv->d3d_device ||
        FAILED(IDirect3DDevice9_Present(priv->d3d_device, &rect, 0, 0, 0))) {
        mp_msg(MSGT_VO, MSGL_V,
               "<vo_direct3d>Trying to reinitialize uncooperative video adapter.\n");
        if (!reconfigure_d3d(priv)) {
            mp_msg(MSGT_VO, MSGL_V, "<vo_direct3d>Reinitialization failed.\n");
            return;
        } else {
            mp_msg(MSGT_VO, MSGL_V,
                   "<vo_direct3d>Video adapter reinitialized.\n");
        }
    }
}

/** @brief libvo Callback: Uninitializes all pointers and closes
 *         all D3D related stuff,
 */
static void uninit(struct vo *vo)
{
    d3d_priv *priv = vo->priv;

    mp_msg(MSGT_VO, MSGL_V, "<vo_direct3d>uninit called.\n");

    uninit_d3d(priv);
    vo_w32_uninit(); /* w32_common framework call */
    if (priv->d3d9_dll)
        FreeLibrary(priv->d3d9_dll);
    priv->d3d9_dll = NULL;
}

/** @brief libvo Callback: Handles video window events.
 */
static void check_events(struct vo *vo)
{
    d3d_priv *priv = vo->priv;

    int flags;
    /* w32_common framework call. Handles video window events.
     * Updates global libvo's vo_dwidth/vo_dheight upon resize
     * with the new window width/height.
     */
    flags = vo_w32_check_events();
    if (flags & VO_EVENT_RESIZE)
        resize_d3d(priv);

    if (flags & VO_EVENT_EXPOSE)
        vo->want_redraw = true;
}

static int draw_slice_textures(d3d_priv *priv, uint8_t *src[], int stride[],
                               int w, int h, int x, int y)
{
    if (!d3d_lock_video_textures(priv))
        return VO_FALSE;

    for (int n = 0; n < priv->plane_count; n++) {
        struct texplane *plane = &priv->planes[n];

        int dst_stride = plane->locked_rect.Pitch;
        uint8_t *pdst = (uint8_t*)plane->locked_rect.pBits
                        + (y >> plane->shift_y) * dst_stride
                        + (x >> plane->shift_x) * plane->bytes_per_pixel;

        memcpy_pic(pdst, src[n], (w >> plane->shift_x) * plane->bytes_per_pixel,
                   h >> plane->shift_y, dst_stride, stride[n]);
    }

    return 0;
}

/** @brief libvo Callback: Draw slice
 *  @return 0 on success
 */
static int draw_slice(struct vo *vo, uint8_t *src[], int stride[], int w, int h,
                      int x, int y)
{
    d3d_priv *priv = vo->priv;

    char *my_src;   /**< Pointer to the source image */
    char *dst;      /**< Pointer to the destination image */
    int  uv_stride; /**< Stride of the U/V planes */

    /* If the D3D device is uncooperative (not initialized), return success.
       The device will be probed for reinitialization in the next flip_page() */
    if (!priv->d3d_device)
        return 0;

    if (priv->use_textures)
        return draw_slice_textures(priv, src, stride, w, h, x, y);

    /* Lock the offscreen surface if it's not already locked. */
    if (!priv->locked_rect.pBits) {
        if (FAILED(IDirect3DSurface9_LockRect(priv->d3d_surface,
                                              &priv->locked_rect, NULL, 0))) {
            mp_msg(MSGT_VO, MSGL_V, "<vo_direct3d>Surface lock failure.\n");
            return VO_FALSE;
        }
    }

    uv_stride = priv->locked_rect.Pitch / 2;

    /* Copy Y */
    dst = priv->locked_rect.pBits;
    dst = dst + priv->locked_rect.Pitch * y + x;
    my_src = src[0];
    memcpy_pic(dst, my_src, w, h, priv->locked_rect.Pitch, stride[0]);

    w /= 2;
    h /= 2;
    x /= 2;
    y /= 2;

    /* Copy U */
    dst = priv->locked_rect.pBits;
    dst = dst + priv->locked_rect.Pitch * priv->src_height
          + uv_stride * y + x;
    if (priv->movie_src_fmt == MAKEFOURCC('Y','V','1','2'))
        my_src = src[2];
    else
        my_src = src[1];

    memcpy_pic(dst, my_src, w, h, uv_stride, stride[1]);

    /* Copy V */
    dst = priv->locked_rect.pBits;
    dst = dst + priv->locked_rect.Pitch * priv->src_height
          + uv_stride * (priv->src_height / 2) + uv_stride * y + x;
    if (priv->movie_src_fmt == MAKEFOURCC('Y','V','1','2'))
        my_src=src[1];
    else
        my_src=src[2];

    memcpy_pic(dst, my_src, w, h, uv_stride, stride[2]);

    return 0; /* Success */
}

/** @brief Maps MPlayer alpha to D3D
 *         0x0 -> transparent and discarded by alpha test
 *         0x1 -> 0xFF to become opaque
 *         other alpha values are inverted +1 (2 = -2)
 *         These values are then inverted again with
           the texture filter D3DBLEND_INVSRCALPHA
 */
static void vo_draw_alpha_l8a8(int w, int h, unsigned char* src,
                               unsigned char *srca, int srcstride,
                               unsigned char* dstbase, int dststride)
{
    int y;
    for (y = 0; y < h; y++) {
        unsigned short *dst = (unsigned short*)dstbase;
        int x;
        for (x = 0; x < w; x++) {
            dst[x] = (-srca[x] << 8) | src[x];
        }
        src     += srcstride;
        srca    += srcstride;
        dstbase += dststride;
    }
}

struct draw_osd_closure {
    d3d_priv *priv;
    D3DLOCKED_RECT locked_rect;
};

/** @brief Callback function to render the OSD to the texture
 */
static void draw_alpha(void *pctx, int x0, int y0, int w, int h,
                       unsigned char *src, unsigned char *srca, int stride)
{
    struct draw_osd_closure *ctx = pctx;
    D3DLOCKED_RECT locked_rect = ctx->locked_rect;

    vo_draw_alpha_l8a8(w, h, src, srca, stride,
        (unsigned char *)locked_rect.pBits + locked_rect.Pitch * y0 + 2 * x0,
        locked_rect.Pitch);

    ctx->priv->is_osd_populated = 1;
}

/** @brief libvo Callback: Draw OSD/Subtitles,
 */
static void draw_osd(struct vo *vo, struct osd_state *osd)
{
    d3d_priv *priv = vo->priv;

    // we can not render OSD if we lost the device e.g. because it was uncooperative
    if (!priv->d3d_device)
        return;

    if (vo_osd_changed(0)) {
        struct draw_osd_closure ctx = { priv };

        /* clear the OSD */
        if (FAILED(IDirect3DTexture9_LockRect(priv->texture_osd.system, 0,
                                              &ctx.locked_rect, NULL, 0))) {
            mp_msg(MSGT_VO,MSGL_ERR, "<vo_direct3d>OSD texture lock failed.\n");
            return;
        }

        /* clear the whole texture to avoid issues due to interpolation */
        memset(ctx.locked_rect.pBits, 0,
               ctx.locked_rect.Pitch * priv->texture_osd.tex_h);

        priv->is_osd_populated = 0;
        /* required for if subs are in the boarder region */
        priv->is_clear_needed = 1;

        osd_draw_text_ext(osd, priv->texture_osd.w, priv->texture_osd.h,
                          priv->border_x, priv->border_y,
                          priv->border_x, priv->border_y,
                          priv->src_width, priv->src_height, draw_alpha, &ctx);

        if (FAILED(IDirect3DTexture9_UnlockRect(priv->texture_osd.system, 0))) {
            mp_msg(MSGT_VO,MSGL_ERR,
                   "<vo_direct3d>OSD texture unlock failed.\n");
            return;
        }

        d3dtex_update(priv, &priv->texture_osd);
    }

    if (priv->is_osd_populated) {
        float tw = (float)priv->texture_osd.w  / priv->texture_osd.tex_w;
        float th = (float)priv->texture_osd.h  / priv->texture_osd.tex_h;

        vertex_osd osd_quad_vb[] = {
            { 0,          0,           0.0f, 0,  0  },
            { vo->dwidth, 0,           0.0f, tw, 0  },
            { 0,          vo->dheight, 0.0f, 0,  th },
            { vo->dwidth, vo->dheight, 0.0f, tw, th }
        };

        d3d_begin_scene(priv);

        IDirect3DDevice9_SetRenderState(priv->d3d_device,
                                        D3DRS_ALPHABLENDENABLE, TRUE);
        IDirect3DDevice9_SetRenderState(priv->d3d_device,
                                        D3DRS_ALPHATESTENABLE, TRUE);

        IDirect3DDevice9_SetTexture(priv->d3d_device, 0,
                        d3dtex_get_render_texture(priv, &priv->texture_osd));

        IDirect3DDevice9_SetFVF(priv->d3d_device, D3DFVF_OSD_VERTEX);
        IDirect3DDevice9_DrawPrimitiveUP(priv->d3d_device, D3DPT_TRIANGLESTRIP,
                                         2, osd_quad_vb, sizeof(vertex_osd));

        IDirect3DDevice9_SetTexture(priv->d3d_device, 0, NULL);

        IDirect3DDevice9_SetRenderState(priv->d3d_device,
                                        D3DRS_ALPHATESTENABLE, FALSE);
        IDirect3DDevice9_SetRenderState(priv->d3d_device,
                                        D3DRS_ALPHABLENDENABLE, FALSE);
    }
}

static void d3d_realloc_eosd_texture(d3d_priv *priv)
{
    int new_w = priv->eosd->surface.w;
    int new_h = priv->eosd->surface.h;

    d3d_fix_texture_size(priv, &new_w, &new_h);

    if (new_w == priv->texture_eosd.tex_w && new_h == priv->texture_eosd.tex_h)
        return;

    mp_msg(MSGT_VO, MSGL_DBG2, "<vo_direct3d>reallocate EOSD surface.\n");

    // fortunately, we don't need to keep the old image data
    // we can always free it
    d3dtex_release(priv, &priv->texture_eosd);

    d3dtex_allocate(priv, &priv->texture_eosd, D3DFMT_A8, new_w, new_h);
}

static D3DCOLOR ass_to_d3d_color(uint32_t color)
{
    uint32_t r = (color >> 24) & 0xff;
    uint32_t g = (color >> 16) & 0xff;
    uint32_t b = (color >> 8) & 0xff;
    uint32_t a = 0xff - (color & 0xff);
    return D3DCOLOR_ARGB(a, r, g, b);
}

static void generate_eosd(d3d_priv *priv, mp_eosd_images_t *imgs)
{
    bool need_reposition, need_upload, need_resize;
    eosd_packer_generate(priv->eosd, imgs, &need_reposition, &need_upload,
                         &need_resize);
    if (!need_upload)
        return;
    // even if the texture size is unchanged, the texture might have been free'd
    d3d_realloc_eosd_texture(priv);
    if (!priv->texture_eosd.system)
        return; // failed to allocate

    // reupload all EOSD images

    // we need 2 primitives per quad which makes 6 vertices (we could reduce the
    // number of vertices by using an indexed vertex array, but it's probably
    // not worth doing)
    priv->eosd_vb = talloc_realloc_size(priv->eosd, priv->eosd_vb,
                                        priv->eosd->targets_count
                                        * sizeof(vertex_eosd) * 6);

    struct eosd_rect rc;
    eosd_packer_calculate_source_bb(priv->eosd, &rc);
    RECT dirty_rc = { rc.x0, rc.y0, rc.x1, rc.y1 };

    D3DLOCKED_RECT locked_rect;

    if (FAILED(IDirect3DTexture9_LockRect(priv->texture_eosd.system, 0,
                                          &locked_rect, &dirty_rc, 0)))
    {
        mp_msg(MSGT_VO,MSGL_ERR, "<vo_direct3d>EOSD texture lock failed.\n");
        return;
    }

    //memset(locked_rect.pBits, 0, locked_rect.Pitch * priv->texture_eosd.tex_h);

    float eosd_w = priv->texture_eosd.tex_w;
    float eosd_h = priv->texture_eosd.tex_h;

    for (int i = 0; i < priv->eosd->targets_count; i++) {
        struct eosd_target *target = &priv->eosd->targets[i];
        ASS_Image *img = target->ass_img;
        char *src = img->bitmap;
        char *dst = (char*)locked_rect.pBits + target->source.x0
                    + locked_rect.Pitch * target->source.y0;
        for (int y = 0; y < img->h; y++) {
            memcpy(dst, src, img->w);
            src += img->stride;
            dst += locked_rect.Pitch;
        }

        D3DCOLOR color = ass_to_d3d_color(img->color);

        float x0 = target->dest.x0;
        float y0 = target->dest.y0;
        float x1 = target->dest.x1;
        float y1 = target->dest.y1;
        float tx0 = target->source.x0 / eosd_w;
        float ty0 = target->source.y0 / eosd_h;
        float tx1 = target->source.x1 / eosd_w;
        float ty1 = target->source.y1 / eosd_h;

        vertex_eosd *v = &priv->eosd_vb[i*6];
        v[0] = (vertex_eosd) { x0, y0, 0, color, tx0, ty0 };
        v[1] = (vertex_eosd) { x1, y0, 0, color, tx1, ty0 };
        v[2] = (vertex_eosd) { x0, y1, 0, color, tx0, ty1 };
        v[3] = (vertex_eosd) { x1, y1, 0, color, tx1, ty1 };
        v[4] = v[2];
        v[5] = v[1];
    }

    if (FAILED(IDirect3DTexture9_UnlockRect(priv->texture_eosd.system, 0))) {
        mp_msg(MSGT_VO,MSGL_ERR, "<vo_direct3d>EOSD texture unlock failed.\n");
        return;
    }

    d3dtex_update(priv, &priv->texture_eosd);
}

static void draw_eosd(d3d_priv *priv)
{
    // we can not render OSD if we lost the device e.g. because it was uncooperative
    if (!priv->d3d_device)
        return;

    if (!priv->eosd->targets_count)
        return;

    d3d_begin_scene(priv);

    IDirect3DDevice9_SetRenderState(priv->d3d_device,
                                    D3DRS_ALPHABLENDENABLE, TRUE);

    IDirect3DDevice9_SetTexture(priv->d3d_device, 0,
                        d3dtex_get_render_texture(priv, &priv->texture_eosd));

    // do not use the color value from the A8 texture, because that is black
    IDirect3DDevice9_SetRenderState(priv->d3d_device,D3DRS_TEXTUREFACTOR,
                                    0xFFFFFFFF);
    IDirect3DDevice9_SetTextureStageState(priv->d3d_device,0,
                                          D3DTSS_COLORARG1, D3DTA_TFACTOR);

    IDirect3DDevice9_SetTextureStageState(priv->d3d_device, 0,
                                          D3DTSS_ALPHAOP, D3DTOP_MODULATE);

    IDirect3DDevice9_SetFVF(priv->d3d_device, D3DFVF_EOSD_VERTEX);
    IDirect3DDevice9_DrawPrimitiveUP(priv->d3d_device, D3DPT_TRIANGLELIST,
                                     priv->eosd->targets_count * 2,
                                     priv->eosd_vb, sizeof(vertex_eosd));

    IDirect3DDevice9_SetTextureStageState(priv->d3d_device,0,
                                          D3DTSS_COLORARG1, D3DTA_TEXTURE);
    IDirect3DDevice9_SetTextureStageState(priv->d3d_device, 0,
                                          D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);

    IDirect3DDevice9_SetTexture(priv->d3d_device, 0, NULL);

    IDirect3DDevice9_SetRenderState(priv->d3d_device,
                                    D3DRS_ALPHABLENDENABLE, FALSE);
}

#define AUTHOR "Georgi Petrov (gogothebee) <gogothebee@gmail.com> and others"

const struct vo_driver video_out_direct3d = {
    .is_new = true,
    .info = &(const vo_info_t) {
        "Direct3D 9 Renderer",
        "direct3d",
        AUTHOR,
        ""
    },
    .preinit = preinit_standard,
    .config = config,
    .control = control,
    .draw_slice = draw_slice,
    .draw_osd = draw_osd,
    .flip_page = flip_page,
    .check_events = check_events,
    .uninit = uninit,
};

const struct vo_driver video_out_direct3d_shaders = {
    .is_new = true,
    .info = &(const vo_info_t) {
        "Direct3D 9 Renderer (using shaders for YUV conversion)",
        "direct3d_shaders",
        AUTHOR,
        ""
    },
    .preinit = preinit_shaders,
    .config = config,
    .control = control,
    .draw_slice = draw_slice,
    .draw_osd = draw_osd,
    .flip_page = flip_page,
    .check_events = check_events,
    .uninit = uninit,
};
